
\documentclass[10pt]{article}
\usepackage[latin1]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{fancyhdr}
\usepackage{pdfpages}
\usepackage{geometry}
\usepackage{caption}
\usepackage{subcaption}

\geometry{verbose,a4paper,tmargin=25mm,bmargin=25mm,lmargin=15mm,rmargin=20mm}
\pagestyle{fancy}
\fancyhf{}
\rhead{S1310307025}
\lhead{Wolfgang Lumetsberger}
\rfoot{Seite \thepage}
\lfoot{UltimateFestivalOrganizer}
\begin{document}
\title{UltimateFestivalOrganizer}
\author{Wolfgang Lumetsberger}
\section{Ultimate - Festival- Orgainzer}

Ultimate Festival Organizer, ist ein Semsterprojekt welches in den Fächern SWK5 und WEA5 als Übung umzusetzen ist.
Eine detaillierte Beschreibung der Softwarelösung, kann aus den Dokument Anforderungen entnommen werden.
\subsection{Ausbaustufe 1}
In der Ausbaustufe 1, ist sowohl die Datenbank, als auch die Datenzugriffsschicht zu Implementieren. Die Datenzugriffsschicht, muss in ADO.NET realisiert werden, und es dürfen keine OR-Mapper verwendet werden.
\subsubsection{Systemaufbau}
In der Ausbaustufe 1 beschäftigen wir uns lediglich mit der Datenbank, beziehungsweise deren Zugriffsschicht. 
Aus den Anforderungen können wir jedoch entnehmen, dass wir in einer der nächsten Ausbaustufen ein Webservice realisieren werden, welches unsere Geschäftslogik abwickelt. 
Diese Schicht, welche die Geschäftslogik enthält, wird in unserem Fall auch sämtlich Prüfungen auf Daten Validität durchführen. 
In der Datenbankschicht kümmern wir uns um diese nicht. 
Anhand der ProjektStruktur der Datenbankschicht, können wir gut den Aufbau erkennen:
\begin{itemize}
\item UltimateFestivalOrganizer.DAL.Common:
Dieses Projekt enthält die POCOS, sowie Interfaces für unsere ein Datenbankobjekt und den DAOS. Weiters enthält es eine DALFactory, welches anhand der Konfiguration die Richtigen DAOS, beziehungsweise Datenbank Objekte erzeugt.
\item UltimateFestivalOrganizer.DAL.SqlServer:
Dieses Projekt enthält die spezifische Implementierung, der DAL.Common Interfaces für eine SqlServer Datenbank.
\item UltimateFestivalOrganizer.DAL.Test:
Dieses Projekt enthält die Tests für die Datenzugriffsschicht.
Weiters enthält dieses Projekt eine eigene Datenbank, für Integration-Tests, und SQL Scripts zum löschen, und wiederherstellen des Urzustandes der Datenbank.
\end{itemize}
Als Datenbank wird eine SQLServer LocalDB verwendet.
\subsubsection{Datenbank}

\begin{figure}[h]
  \centering
   \includegraphics[scale = 0.50]{./images/ERD.PNG}
   \caption{Entity RelationShip Diagram}
	 \label{ERD}
\end{figure}

Da Performance und Artists, in unserer Geschäftslogik nicht gelöscht werden, wurde ein Flag eingefügt, für Cancled bzw. Deleted. Es wird ein löschen auf Datenbankebene jedoch erlaubt.
Die zwei Felder dienen dazu, um eben in der Geschäftslogik nicht löschen zu müssen, sondern nur als Gelöscht makieren zu können.
Um die Datenzugriffschicht zu erleichtern, wurde auf jede Entiät ein Surogate gelegt. Die Tatsächlichen Keys, wurden jedoch mit Unique-Constraints realisiert.

\subsubsection{Datenzugriffs-Schicht}
\begin{itemize}
\item UltimateFestivalOrganizer.DAL.Common
\begin{itemize}
\item POCOS:
Für jede Entität wurde ein POCO erstellt. Um später einen Dynamischen Dao verwenden zu können, gelten für jedes POCO folgende Konventionen.
\begin{itemize}
\item Jedes POCO leitet von der Basis-Klasse BaseEntity ab
\item Jedes POCO enthält als Klassen-Attribut das Table , mit welchem der Name der Datenbanktabelle angegeben wird.
\item Jedes POCO enthält als PropertyAttribute Id und AutogeneratedId, auf jenes Property welches die Id darstellt.
\end{itemize}
Da im Laufe der Entwicklung Surrogaten als PrimaryKey eingeführt worden sind, ist es nicht mehr notwendig, in einem abgeleiteten POCO das Attribut Id und AutogeneatedId zu verwenden. Dies wird bereits im BaseEntity richtig gesetzt.
\begin{figure}[hbtp]
  \centering
   \includegraphics[scale = 0.75]{./images/KD_DAL_Common_POCOS.PNG}
   \caption{Klassendiagramm Pocos}
	 \label{Klassendiagramm Pocos}
\end{figure}
\item Dao:
Im Package Common, werden lediglich Interfaces für die Daos deklariert. 
Hier gilt wiederum, jedes neu erstellte Dao, muss vom TemplateDao IBaseDao ableiten. Die Implementierung dieses Abstrakten DAO, wird später so ausgeführt werden, dass Basis Funktionalitäten wie Insert, Update, Delete, findById, findAll zur verfügung gestellt werden. 
Das Interface IDao wird benötigt, um später dynamisch spezifische Daos erzeugen zu können. Lediglich die Implemtierung vom BaseDao implementiert auch dieses Interface. Alle anderen Daos leiten nur vom BaseDao ab.
\begin{figure}[hbtp]
  \centering
   \includegraphics[scale = 0.75]{./images/KD_DAL_Common_IDAOS.PNG}
   \caption{Klassendiagramm Dao Interfaces}
		\label{Klassendiagramm Dao Interfaces}
\end{figure}
\item Util:
Entählt Hiflsmethoden um z.B. die Attribute eines POCOs auslesen zu können.

\item IDatabase:
Interface, für ein Datenbankobjekt, welches Transaktionen mithilfe von ADO.NET durchführt.

\item DALFactory:
In der DALFactory werden anhand von der Projektkonfigurationsdatei, DatenbankObjekte aber auch Daos erstellt. Weiters wurde eine Methode erstellt, welche es schafft, anhand eines POCO types den richtigen DAO zurück zuliefern. Um dies realisieren zu können, wird auch das nicht typisierte Interface IDao benötigt.
\end{itemize}
\item UltimateFestivalOrganizer.DAL.SqlServer
\begin{itemize}
\item Dao:
BaseDao implementiert die Schnittstelle IDao, sowie IBaseDao. Funktionen wie findAll, findById, Insert, Update, Delete werden hier dynamisch per Reflection realisiert. 
Die Schnittstelle IDao ist so implementiert, das sie lediglich die Funktionalitäten, der BaseDao aufruft. 
\begin{lstlisting}

public IList<T> findAll()
{
	DbCommand command = database.CreateCommand(this.GetDefaultSelect());
  using (IDataReader reader = database.ExecuteReader(command))
  {
		return ConvertResultToList(reader);
  }
}

object IDao.findAll()
{
	return findAll();
}
\end{lstlisting}

Diese Methode der Implementierung wird benötigt, da es beim dynamischen Mappen vom ResultSet sein kann, dass ein ForeignKey aufgelöst werden muss. Dann benötigen wir einen neuen Dao, um dieses ForeignKey Objekt zu holen. Um dann nicht im Generischen Dao entscheiden zu müssen, welchen Typ von Dao man benötigt, kann man so einen Dao von der Factory holen, indem man einfach den Typ der Entität mitgibt. Diese entscheidet welchen Dao man benötigt, und liefert diesen als IDao zurück.

Wichtig, damit diese Basisimplementierungen funktionieren, muss sich im Gesamten an die oben genannten Konventionen gehalten werden. Ist dies nicht der Fall, muss man in den speziellen Dao Ausprägungen die Funktionalitäten überschreiben. 

Es wäre angedacht, auch eine generische Suchmethode zu entwickeln. Diese wäre hilfreich um zum Beispiel Datensätze zu Suchen, welche in einem Bestimmten Zeitraum liegen oder ähnliches. Derzeit ist es Zeitlich aber noch nicht möglich gewesen, diese zu realisieren. Man kann, falls unbedingt benötigt, diese ja auch gezielt im jeweiligen Dao aus-programmieren. Da sie für das Webservice jedoch hilfreich sein werden, werden diese in der nächsten Ausbaustufe sicher noch entwickelt werden.
\begin{figure}[hbtp]
  \centering
   \includegraphics[scale = 0.50]{./images/KD_DAL_SQL_impl.PNG}
   \caption{Klassendiagramm Implementierung Daos}
	 \label{Klassendiagramm Implementierung Daos}
\end{figure}
\end{itemize}

\item{UltimateFestivalOrganizer.DAL.Test}
In diesem Projekt werden lediglich die Datenzugriffsfunktionen getestet. Da es Hier keinen Sinn macht, die Funktionen wirklich Unit zu Testen, wurden hier Integration Tests erstellt.
Alle Tests werden von einer Basis-Klasse abgeleitet. Diese Klasse enthält TestInitialize und CleanUp methoden. 
In dem Projekt existiert eine App.config, in welcher das Datenbankfile, sowie ein Ordern für Delete/Create/Insert files, welche vor jedem Test automatisch von der Basis Testklasse ausgeführt wird.
\begin{itemize}
\item{BaseTest}
Der Test ist die Basisklasse einer jeden Testklasse in diesem Projekt. In der Methode TestInitzialize wird hier jeweils die TestDatenbank komplett bereinigt. Danach wird die Struktur neu erstellt, und es werden definiert Testdatensätze eingefügt. Daher ist es wichtig, dass jeder Testfall von dieser Methode ableitet, damit sichergestellt ist, das die Tests immer auf bereinigten Daten ausgeführt werden.
\end{itemize}
Mit den im Projekt enthaltenen Testfällen, wird folgendes Ergebnis erzielt:
\begin{figure}[hbtp]
  \centering
   \includegraphics[scale = 0.50]{./images/Testabdeckung_DAL.PNG}
   \caption{DAL Testabdeckung}
	 \label{Klassendiagramm Implementierung Daos}
\end{figure}
\end{itemize}
\end{itemize}

\subsection{Ausbaustufe 2}
In dieser Ausbaustufe wird sowohl die Business-Logik, als auch eine GUI entwickelt. 
\subsubsection{BusinessLogik}
Die BusinessLogik dient zur Abbildung von Speichern, Bearbeiten, holen von Daten. Dazu werden in erster Linie zwei Interfaces erstellt. IAdministrationService, enthält alle Methoden, die für die Applikation benötigt werden, um Daten zu bearbeiten zu kommen. In einem zweiten Interface, werden jene funktionalitäten abgebildet, welche nur lesenden Zugriff erhalten. Die Implementierung ist so erfolgt, dass alle Komponenten keine Abhängigkeiten haben. Das Business Logik Projekt, hat also nur eine Direkte abhängikeit zum Common, aber nicht zu einer konkreten Implementierung der DAL Klassen.
Eine Factory wird benutzt, um eine konkrete Implementierung der AdministrationInterfaces zu bekommen.
Aus Zeitlichen gründen, wird die BusinessLogik, welche nur schreibend zugreift, und z.B. für das WebService verwendet wird, erst dann entwickelt, wenn es auch wirklich benötigt wird.
\begin{figure}[hbtp]
  \centering
   \includegraphics[scale = 0.50]{./images/KD_BUSINESS_LOGIC.PNG}
   \caption{Klassendiagramm Business Logik}
	 \label{Klassendiagramm Business Logik}
\end{figure}
In dem Projekt BusinessLogik.Test befinden sich Unit und Integration Tests für die oben genannten Implementierungen.

\subsubsection{Commander}
In diesem Projekt wird eine WPF-Applikation erstellt. Dieses Projekt hat eine Abhängikeit zum Common, und zur BusinessLogik. In der MainView wird ein AdministrationService erzeugt, welches dann an alle anderen ViewModels per Konstruktor mit übergeben wird. Die erzeugung erfolgt über die Factory. Schöner wäre es eventuell noch, wenn man die gesamtheit der Objekte über Dependency Injektion lösen würde. In diesem Fall ist es aber denke ich eine ebenfalls praktikable Lösung, wenn man es sich einmal erzeugt, und über den Konstruktor in die restlichen ViewModels mitzieht. 

Die Kommunikation zwischen den ViewModels funktioniert per Messaging. Diese Methode liefert MVVM-Light, welches aus diesem Grund, für genau diesen einen Zweck verwendet wird. In der AppMessages Klasse befinden sich alle möglichen Messages. Alle ViewModels können sich danach auf diese Registrieren, und diese werfen. Z.B. Ändert sich eine Catagory wird eine CatagoryChanged message geworfen, und die anderen ViewModels, welche Catagories benötigen, können dies auf aktuellen stand bringen.

Zur Validierung verwende ich das Framework MVVM-Validation. Dazu wurde im BaseModel IDataErrorInfo implementiert, um die Fehler auch korrekt anzuzeigen. 

Zur Anzeige generell wurde MahAppsMetro verwendet. Dies bringt einen großen Designvorteil, und zum Beispiel eine vielzahl von Buttons usw..

Es gibt in meiner Implementierung so gut wie keinen Code-Behind. Lediglich in der AdministrationWindow.xaml wird der richtige DataContext einmal gesetzt. Weiters befindet sich auch die Anzeige von zwei MessageBoxen hier. Die BusinessLogik, wird ebenfalls über eine Faktory geholt, und hier beim Anlegen des AdministrationVM zugewiesen.

 Der FileDialog wurde ebenfalls über einen Service angesprochen. Diesen Service habe ich jedoch nicht in die BusinessLogik gepackt, sondern im GUI Projekt gelassen. Der Grund ist, dass dieses Service ja ein Fenster öffnet, um eine Datei auszuwählen, wesshalb es für mich eher in das GUI projekt gehört.

Testfälle für die ViewModels wurden nicht erstellt. In der Praxis sollte man aber durchaus die ViewModels Unit-Testen.

Für das Senden von Mails, kann in der App.config konfiguriert werden, dass die Mails nicht direkt versendet werden, sondern einfach in einen Ordner gespeichert werden. Um die Tests zu beschleunigen und zu vereinfachen, wurde dies so konfiguriert.

\begin{figure}[hbtp]
  \centering
   \includegraphics[scale = 0.75]{./images/KD_COMMANDER.PNG}
   \caption{Klassendiagramm Dao Interfaces}
		\label{Klassendiagramm Dao Interfaces}
\end{figure}

Die einzelnen Administrationsschritte wurden in einzelne Tabreiter aufgebaut. Jeder Reiter enthält dabei die Gesamte funktionalität um z.B. die Artisten zu bearbeiten. Alle Felder, welche validiert werden müssen, und fehlerhaft werden, werden rot umrahmt.
Die GUI wurde wie folgt designed, und stellt folgende Funktionalitäten dar:
\begin{itemize}
\item{Login}
Gültige Logindaten um sich einzuloggen sind admin@test.at/admin.
Gibt man ungültige LoginDaten ein, bleibt man am gleichen Screen und eine Fehlermeldung wird angezeigt.
\begin{figure}[hbtp]
  \centering
   \includegraphics[scale = 0.75]{./images/LOGIN.PNG}
   \caption{Login}
		\label{Login}
\end{figure}

\item{Artists}
Hier können Artisten bearbeitet, gelöscht oder hinzugefügt werden. Es können nur jene Artists gelöscht werden, welche keine aufführung haben.
\begin{figure}[hbtp]
  \centering
   \includegraphics[scale = 0.75]{./images/ARTISTS.PNG}
   \caption{Administration Artists}
		\label{Administration Artists}
\end{figure}

\item{Catagories}
Erklärung siehe Artists.
\begin{figure}[hbtp]
  \centering
   \includegraphics[scale = 0.75]{./images/CATAGORIES.PNG}
   \caption{Administration Catagories}
		\label{Administration Catagories}
\end{figure}

\item{Venues}
Erklärung siehe Artists.
\begin{figure}[hbtp]
  \centering
   \includegraphics[scale = 0.75]{./images/VENUES.PNG}
   \caption{Administration Venues}
		\label{Administration Venues}
\end{figure}

\item{Performances}
Der Button Email in der Menü-Leiste sendet, das Tagesprogramm an alle beteiligten User. Möchte man nur einen Artist bescheid geben, so kann der Email-Button am entsprechenden Element verwendet werden.
Vor dem Speichern wird das ganze Programm validiert. Mit dem Häckchen kann das gesamte Tagesprogramm validiert werden. Wird ein Artist mit dem Dropdown geändert, so wird im hintergrund sofort eine Validierung durchgeführt.

\begin{figure}[hbtp]
  \centering
   \includegraphics[scale = 0.75]{./images/Performances.PNG}
   \caption{Administration Performances}
		\label{Administration Performances}
\end{figure}

Die Meldung das die Validierung erfolgreich war, wird nicht angezeigt, wenn die Validierung impliziet im hintergrund läuft. Nur wenn sie mit dem Häckchen gestartet wurde.

\begin{figure}[hbtp]
  \centering
   \includegraphics[scale = 0.75]{./images/Performances_valid.PNG}
   \caption{Administration Performances}
		\label{Administration Performances}
\end{figure}

\end{itemize}
\newpage
\listoffigures
\end{document}
